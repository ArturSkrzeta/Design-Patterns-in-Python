<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px;"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Design Patterns in Python</h2>
										<h3>Intro</h3>

										<ul>
											<li>Becasue of Python's dynamic nature, there are some differences in implementation with comaprison to other static typed laguages for which design patterns were originally made up.</li>
											<li>Design patterns apply to object-oriented application design that appears in different scenarios where we model logic or problem that we try to solve with this app.</li>
											<li>In other words, design patterns are abstract ideas on objects layout, how they interact with each other for in a particular scenario.</li>
											<li>One again due to Pythonic nautre, some of desing matterns can't fid their implementation but some of them are already embedded in Python itself.</li>
											<li>The best thin about them is that they provide common language to communicate design ideas wihing developers effectively.</li>
										</ul>

										<p style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:4px;"><b>Creational Desing Patterns</b></p>

										<h5>Factory:</h5>
										<ul>
											<li>Everythin in Python is an object and can be treated equally no metther if it is a class, a function or custom objects attached to variable. They can be simply created, passed as parameter or assigned.</li>
											<li>Due to this fact factory pattern is not really needed. We can simply creat function that accepts a class as a parameter to create a set of objets.</li>
											<li>Code example:
<!-- code area start -->
<pre>
class <span style="color:#00ffea">ExampleClass</span>:
  def __init__(self, x, y):
    self.x = x
    self.y = y

def main():
  list_of_objects = [<span style="color:#00ffea">ExampleClass(x, x*2)</span> for x in range(10)]
  print(list_of_objects[2].y)

--------------
# output:
# 4
</pre>
<!-- code area stop -->
											</li>
										</ul>

										<h5>Singleton:</h5>
										<ul>
											<li>It is a type of creational pattern that restrics to have only one object of a particular type.</li>
											<li>No matter how many instantiation I want to make:
												<br>
												<code>s1 = Singleton()</code><br>
												<code>s2 = Singleton()</code><br>
 												there will be always one object that variables <code>s1</code> and <code>s2</code> points to.</li>
										</ul>

										<h5>Builder:</h5>
										<ul>
											<li>Without builder pattern:
												<br>
												- Typical apporach would be creating base class and then creating a set of subclasses that extend the base class.
												Each subclass would bring some extenstions to fulfil its own specialized requirement.<br>
												- The danger of this approch is ending up with a big amount of subclasses and each additional requirement that comes in grows that hierarchy even more.
											</li>
											<li>With Builder pattern:
												<br>
												<code>Builder makes creating complex objects from a baisc object much easier</code><br>
												- Useful in situation when we have a basic model and based on that model we want to create multiple modifications of that model,<br>
												- for example a plain house is a basic model, however a house with swimming pool and 3 floors is a modification of the basic model of house.
											</li>
											<li>Builder organizes the code into series of steps that are executed one by one when building an object.
													Importantly, we do not have to call all of the steps.
													We have to call only that steps that are necessary for a specific model of house from example above.
													We can call each step in the sequence we want on our own or we can use a special class called director which has a specific step sequence prepared up front.
											</li>
											<li>Code example:
<!-- code area start -->
<pre>
from abc import ABC

class <span style="color:#00ffea">Builder(</span>ABC<span style="color:#00ffea">)</span>:

  @abstractproperty
    def product(self) -> None:
      pass

  @abstractmethod
    def produce_part_a(self) -> None:
      pass

  @abstractmethod
    def produce_part_b(self) -> None:
      pass

  @abstractmethod
    def produce_part_c(self) -> None:
      pass

class <span style="color:#e48eff">ConcreteBuilder1(</span><span style="color:#00ffea">Builder</span><span style="color:#e48eff">)</span>:

  def __init__(self) -> None:
    self.reset()

  def reset(self) -> None:
    self._product = Product1()

  @property
  def product(self) -> Product1:
    product = self._product
    self.reset()
    return product

  def produce_part_a(self) -> None:
    self._product.add("PartA1")

  def produce_part_b(self) -> None:
    self._product.add("PartB1")

  def produce_part_c(self) -> None:
    self._product.add("PartC1")
</pre>
<!-- code area stop -->
												- Builder abstract class has interface with abstract metods which are the steps of building an object.<br>
												- Actual builder classes follow builder interface and provide implementation for building steps:<br>
												&nbsp&nbsp&nbsp&nbsp>&nbsp produce_part_a,<br>
												&nbsp&nbsp&nbsp&nbsp>&nbsp produce_part_b,<br>
												&nbsp&nbsp&nbsp&nbsp>&nbsp produce_part_c.<br>
												- Each newly-created builder instance should be a blank object which will be extending with specific steps as per needs.<br>
<!-- code area start -->
<pre>
class <span style="color:#00ff45">Product1()</span>:

  def __init__(self) -> None:
    self.parts = []

  def add(self, part) -> None:
    self.parts.append(part)

  def list_parts(self) -> None:
    print(f"Product parts: {', '.join(self.parts)}", end="")
</pre>
<!-- code area stop -->
												- Final object of Product1 class can be a basic product (no additional parts) or very extended protduct (multiple parts).<br>
												- How many parts an object inlcudes - it depends on how many and what building methods client, using the code, calls.<br>
												- Methods (building steps) that are very specialized for that builder's objects should be declared in that builder instead of interface.
													It's not so good practice to keep methods in the interface that wont be used by some sub-classes.<br>
												- We can have multiple builders for building different kind of objects, as to our house example, houses can have different walls: wooden or concrete.<br>
												- We can use director class that orchestrate building specific objects by ordered sequence of steps.
											</li>
										</ul>

										<p style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:4px;"><b>Behavioral Desing Patterns</b></p>

										<h5>State:</h5>
										<ul>
											<li>Without state pattern:
												<br>
												- Common practice when not using state pattern is implementing a lot of if statements that select appropriate behaviour depending on the current object's state.<br>
												- In that case a state is basically a set of values of the object's properties.<br>
												- The biggest disadvantage of this solution is once we start adding more states and state-dependent bahaviours the code becomes diffictul to maintain.<br>
												- This is because the whole logic may require changing state condtions in every method it applies.<br>
												- And this is pretty certain that at the app's desing stage we may be not able to predict all the possible states and bahaviours. Hence, the problem gets bigger as project evolves.
											</li>
											<li>With state pattern:
												<br>
												<code>It allows object to alter ist behaviour when its internal state changes</code><br>
												-	The main idea is that there is a set of finite number of predetermined states that the object can be in at any give moment. Depending on the current state, the object can be behaving differently.<br>
												-	The solution that state pattern provides is to create new classes for all possible states the object can take and input all state-specific behavior into these classes.<br>
												-	The main obejct, whose state we observe, stores reference to one of the state objet representing its current state and delegates state-related behaviour to that object.<br>
												-	In the State pattern, the particular states are aware of each other and on states we can initiate transition to another one.
											</li>
											<li>Code example:
<!-- code area start -->
<pre>
from abc import ABC, abstractmethod

class <span style="color:#00ffea">State(</span>ABC<span style="color:#00ffea">)</span>:

  @abstractmethod
  def handle(self):
    pass

class <span style="color:#e48eff">Context</span>:

  def __init__(self, state):
    self.transition_to(state)

  def transition_to(self, state):
    print(f"Context: Transition to {type(state).__name__}")
    self._state = state                 # current state
    self._state.context = self          # current context that got a specifc state

  def request(self):
    self._state.handle()

class <span style="color:#ffe200">StateA(</span><span style="color:#00ffea">State</span><span style="color:#ffe200">)</span>:

  def handle(self):
    print("<span style="color:#ffe200">StateA</span> handles request and wants to change the state of the context.")
    self.context.transition_to(<span style="color:#00ff45">StateB()</span>)

class <span style="color:#00ff45">StateB(</span><span style="color:#00ffea">State</span><span style="color:#00ff45">)</span>:

  def handle(self):
    print("<span style="color:#00ff45">StateB</span> handles request and wants to change the state of the context.")
    self.context.transition_to(<span style="color:#ffe200">StateA()</span>)

def main():
  context = <span style="color:#e48eff">Context(</span><span style="color:#ffe200">StateA()</span><span style="color:#e48eff">)</span>
  context.request()
  context.request()

if __name__ == "__main__":
  # The client code.
  main()
</pre>
<!-- code area stop -->
											</li>
										</ul>

										<p style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:4px;">Structural Design Patterns</p>

										<h5>...</h5>
										<ul>
											<li>...</li>
											<li>...</li>
										</ul>

									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">Design Patterns</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>...:</h5>
									<ul>
										<li>...</li>
									</ul>

								</div>
							</section>

						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<p>No specific installation required.</p>
								</div>
							</section>

						<!-- Five -->
							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="#">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
